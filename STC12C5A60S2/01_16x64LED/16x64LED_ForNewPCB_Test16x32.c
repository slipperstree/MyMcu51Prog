#include <intrins.h>
#include <STC89C52.h>
#define uint unsigned int
#define uchar unsigned char

// LED屏 单色 16x32 大尺寸 #########################################################################################
// 接口 ：（非08接口，不要用2x8线直接在自己画的板子上，要用杜邦线单独接线）
//     OE    ： 高电平使能（板子上接在138的E3上, E1,E2已经直接接地使能了）
//     N     ： 接地 (7个，不用全接，内部已经连在一起了)
//     A/B   ： 行选（板子上接在138的A0,A1上）
//     C     ： ？？（138的A2直接接地了??）
//     S     ： SCK 列数据移位时钟（板子上接在595的CLK上）
//     L     ： LAT 锁存（板子上接在595的LE上）
//     R     ： DATA IO 数据口（板子上接在595的LE上）
//     G     ： 绿色灯用（本程序不使用）
//     D     ： 未知（本程序不使用）

// 根据硬件连接，138的输出为下表（A2固定接地）
// ------------------------------------
// A2 A1 A0 | Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
// ------------------------------------
// L  L  L  | L  H  H  H  H  H  H  H
// L  L  H  | H  L  H  H  H  H  H  H
// L  H  L  | H  H  L  H  H  H  H  H
// L  H  H  | H  H  H  L  H  H  H  H
// ------------------------------------

// ================================================================================================
// 硬件示意图(从背面PCB的方向看的，并不是正面LED的方向)
// HC595列数据(16字节，128位)
// HC138行数据(4行)
// ================================================================================================
//                    00 01 ... 07  .--32 33 ... 39  .--XX XX ... XX  .--XX XX ... XX
// 第 01 行：    Y0 ->           |   |            |   |            |   |            |    
// 第 02 行：    Y1 ->           |   |            |   |            |   |            |    
// 第 03 行：    Y2 ->           |   |            |   |            |   |            |    
// 第 04 行：    Y3 ->           |   |            |   |            |   |            |    
//                    .---------`   |  .---------`   |  .---------`   |  .---------`    
//                    |             |  |             |  |             |  |              
//                    08 09 ... 15  |  40 41 ... XX  |  XX XX ... XX  |  XX XX ... XX
// 第 05 行：    Y0 ->           |   |            |   |            |   |            |    
// 第 06 行：    Y1 ->           |   |            |   |            |   |            |    
// 第 07 行：    Y2 ->           |   |            |   |            |   |            |    
// 第 08 行：    Y3 ->           |   |            |   |            |   |            |    
//                    .---------`   |  .---------`   |  .---------`   |  .---------`    
//                    |             |  |             |  |             |  |              
//                    16 17 ... 23  |  XX XX ... XX  |  XX XX ... XX  |  XX XX ... XX
// 第 09 行：    Y0 ->           |   |            |   |            |   |            |    
// 第 10 行：    Y1 ->           |   |            |   |            |   |            |    
// 第 11 行：    Y2 ->           |   |            |   |            |   |            |    
// 第 12 行：    Y3 ->           |   |            |   |            |   |            |    
//                    .---------`   |  .---------`   |  .---------`   |  .---------`    
//                    |             |  |             |  |             |  |              
//                    24 25 ... 31--`  XX XX ... XX--`  XX XX ... XX--`  XX XX ... XX
// 第 13 行：    Y0 -> 
// 第 14 行：    Y1 -> 
// 第 15 行：    Y2 -> 
// 第 16 行：    Y3 -> 
// ================================================================================================
// 硬件连接示意图，本显示屏传输数据的方法需要做1/4行扫描：
// 扫描1/4
//   HC595 串行输入 16个字节 的数据 （第01行，第05行，第09行，第13行）
//   HC138 行选择Y0输出
// 扫描2/4
//   HC595 串行输入 16个字节 的数据 （第02行，第06行，第10行，第14行）
//   HC138 行选择Y1输出
// 扫描3/4
//   HC595 串行输入 16个字节 的数据 （第03行，第07行，第11行，第15行）
//   HC138 行选择Y2输出
// 扫描4/4
//   HC595 串行输入 16个字节 的数据 （第04行，第08行，第12行，第16行）
//   HC138 行选择Y3输出
// 位移595数据的时候要注意数据的先后顺序，先传的数据显示在最下面


// 点阵屏定义 #########################################################################################
sbit EN_port 	= P3^6;
sbit DATA_R1    = P3^5;
sbit CLK_port 	= P1^7;
sbit Latch_port = P1^6;

// 红色单色屏未使用定义
sbit DATA_R2    = P3^4;
sbit DATA_G1    = P1^4;
sbit DATA_G2    = P1^5;

#define ABCD_port P1  //HC138 ABCD端口定义
sbit D_port = P1^3; //-> HC138 E1 低电平使能
sbit C_port = P1^2;
sbit B_port = P1^1;
sbit A_port = P1^0;

void testSetFullScreenByte(uchar);

void delay_ms(uchar n)
{
	uchar x,y;
	for(x=n;x>0;x--)
	{
		for(y=5;y>0;y--);	
	}
}

uint ttTimes = 0;
void main()
{
	uchar dat=0;
	/*HC138输出有效，关闭显示*/
	EN_port = 0;
	//testSetFullScreenByte(0xFE);
    while(1){
		ttTimes++;
		if (ttTimes >= 5000) {
			dat++;
			ttTimes = 0;
		}
		testSetFullScreenByte(dat);
	}
}

// test---------------------------------------------------------------
// 将整个屏幕所有数据设置成同一个数据(如果传入0xFF就是全部点亮)
// 本函数用于测试LED板子，需要放在主程序while循环中才可以（模块需要不停扫描否则不显示）
uchar nowBright=0;
uchar maxBright=250;
uchar setBright=1;
uchar row=0;

uchar flg=0;
void testSetFullScreenByte(uchar bData)
{
	uchar i=0;
	uchar temp=0;

	nowBright++;
	if (flg == 0 && nowBright >= maxBright) {
		//flg = 1;
		nowBright = 0;

		// 将每一位移入595的移位寄存器
		// SM16106的LE（锁存）设置为低电平，数据移入
		Latch_port = 0;
		
		// 每扫描一次移入16个字节的数据
		for(temp=0;temp<16;temp++){

			for(i=0;i<8;i++){
				CLK_port = 0;

				if(((bData<<i)&0x80)!=0) {
					DATA_R1 = 0;
				} else {
					DATA_R1 = 1;
				}

				// 上升沿移入数据
				CLK_port = 1;
			}
		}

		/*SM16106的LE（锁存）设置为高电平，数据锁存*/
		Latch_port = 1; 
		

		//控制138打开指定行的输入
		 ABCD_port = (ABCD_port & 0xf0)|row;
		// D_port = 1;
		// A_port = 1;
		// B_port = 1;
		// C_port = 1;

		row++;
		if(row == 4) row = 0;
	}
	
	if (nowBright < setBright) {
		/*HC138输出有效，打开显示*/
		EN_port = 1;
	} else {
		/*HC138输出有效，关闭显示*/
		EN_port = 0;
	}

}